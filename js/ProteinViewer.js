/**
 * Creates a protein viewer widget and returns protein viewer object.
 * Uses PV (https://biasmv.github.io/pv/) internally to facilitate 
 * actual protein rendering/viewing.
 *
 * @param root The dom element being registered as a protein viewer.
 */
let ProteinViewer = function(root) {

    // Create frequently used variables and references to frequently used dom elements.
    let pdb = root.getAttribute("data-pdb");
    let modelSelect = root.querySelector(".protein-viewer__model-select");
    let colorSelect = root.querySelector(".protein-viewer__color-select");
    let atomLabel = root.querySelector(".protein-viewer__atom-label");

    // Construct new PV viewer object on the root elem. Instances of PV viewer manage and
    // render molecules. For more details and a description of some of the options, see:
    // https://pv.readthedocs.io/en/v1.8.1/viewer.html#pv.Viewer
    let viewerObj = pv.Viewer(root, {
        antialias: true,
        quality : 'medium',
        fog: false,
        selectionColor : "#000"
    });

    // Get a reference to the canvas generated by pv.Viewer(). Used to calculate atom 
    // highlighting, however it might not be necessary. Using viewerObj.boundingClientRect() 
    // as per https://pv.readthedocs.io/en/v1.8.1/sample-hover.html or using click events
    // as per https://pv.readthedocs.io/en/v1.8.1/viewer.html#mouse-interaction-events-click-doubleclick
    // seem like note worthy alternatives.
    let pvCanvas = root.querySelector("canvas");

    // Create custom gradients to be used in in structure coloring.
    let chainGradient = pv.color.gradient(["#FF6C0C", "#5A2328", "#70A0AF", "#A8C686", "#003B4C"]);
    let ssGradient = pv.color.gradient(["#CCCCCC", "#003B4C", "#FF6C0C"]);

    let initialized = false;
    // Certain model representations are tough to render and can crash. This variable determines when to 
    // remove those representations in processFetchRes() on models that are larger than defined bytes.
    let largeFileSize = 5000000;
    // Protein look-up table used to display atom label when structures are selected.
    let proteinDict = {
        "ALA": "alanine",
        "ARG": "arginine",
        "ASN": "asparagine",
        "ASP": "aspartate",
        "CYS": "cysteine",
        "GLU": "glutamate",
        "GLN": "glutamine",
        "GLY": "glycine",
        "HIS": "histidine",
        "ILE": "isoleucine",
        "LEU": "leucine",
        "LYS": "lysine",
        "MET": "methionine",
        "PHE": "phenylalanine",
        "PRO": "proline",
        "SEC": "selenocysteine",
        "SER": "serine",
        "THR": "threonine",
        "TRP": "tryptophan",
        "TYR": "tyrosine",
        "VAL": "valine",
        "HOH": "water",
        "XAA": "other"
    };
    // viewerStructs used to reference all structures in model when changing model type.
    // prevPicked used for removing modifications made to atoms during selection when a new atom is selected.
    let viewerStructs, prevPicked;;

    /**
     * Initialize protein viewer fetching pdb file. Not called in ProteinViewer 
     * but instead returned as public method to give control of when pdb file is loaded.
     */
    let init = function() {
        // Remove spheres/balls+sticks models from mobile screen sizes since they are tougher to render.
        if(window.innerWidth < 900) {
            for(let option of modelSelect.options) {
                if(option.value == "spheres" || option.value == "ballsAndSticks") modelSelect.removeChild(option);
            }
        }

        fetch(`https://www.cellstructureatlas.org/pdb/${pdb}.pdb1`)
                .then(processFetchRes)
                .then(loadPdb);

        // Set initialized to true since we started fetching the pdb file.
        this.initialized = true;
    };

    /**
     * Fetch callback used in init() function after fetching pdb file. Performs 
     * pre-screening of fetch response before returning response body.
     * 
     * @param res fetch response returned from pdb file.
     */
    let processFetchRes = function(res) {
        // Remove tough model representations if response content is larger than largeFileSize.
        let contentLength = res.headers.get("content-length");
        if(contentLength > largeFileSize) {
            for(let option of modelSelect.options) {
                if(option.value == "ballsAndSticks") modelSelect.removeChild(option);
            }
        }

        return res.text();
    };

    /**
     * Fetch callback used in init() function after pdf fetch response is 
     * parsed by processFetchRes(). Performs initial render of pdb to pv 
     * viewer.
     * 
     * @param data string pdb data.
     */
    let loadPdb = function(data) {
        // pv.io.pdb() loads structure from data string and returns an array of structure model objects.
        // loadAllModels option is needed to load all models present in data string.
        viewerStructs = pv.io.pdb(data, { loadAllModels: true });

        // Initially render all models with cartoon model and our custom chain gradient.
        viewerStructs.forEach(function(viewerStruct, index) {
            viewerObj.cartoon(`structure_${index}`, viewerStruct, { color: pv.color.byChain(chainGradient) })
        });

        // Adjust zoom level so all objects are visible on screen and occupy as much space as possible.
        viewerObj.autoZoom();
    };

    /**
     * Resize pv viewer element fill root element. Fired on window resize, 
     * and returned as public method to allow manual resizing.
     */
    let resizeViewer = function() {
        // Use built in pv viewer.resize() method to correctly resize viewer object to root.
        viewerObj.resize(root.offsetWidth, root.offsetHeight);
    };

    /**
     * Initializes functionality to read touch events and fires atom selection
     * when applicable. Fired on root touchstart.
     * 
     * handleTouch() and handleMouseDown() could possibly be consolidated into 
     * a pointer based event function since they are very similar.
     * 
     * @param event event object generated by touchstart event.
     */
    let handleTouch = function(event) {

        // handleTouch helper function to that is fired on touchend. Fires atom selection on 
        // valid taps and performs touch functionality clean up since touch event is ending. 
        let handleTouchend = function() {
            if(validTap) {
                // Use canvas generated by pv.Viewer() to calculate position of touch event. However, it 
                // might be unnecessary. Refer to initialization of pvCanvas variable for possible alternatives.
                let pos = { x: event.touches[0].clientX - pvCanvas.getBoundingClientRect().x, y: event.touches[0].clientY - pvCanvas.getBoundingClientRect().y };
                
                handleInput(pos);
            }

            // Remove touchmove listener as touch events are over.
            root.removeEventListener("touchmove", handleTouchmove);
        }

        // handleTouch helper function to flag touches as invalid for atom selection if the user drags
        // viewer (most likely panning/rotating structure).
        let handleTouchmove = function() {
            validTap = false;
        }

        let validTap = true;
        root.addEventListener("touchend", handleTouchend, { once: true });
        root.addEventListener("touchmove", handleTouchmove, { once: true });
    };

    /**
     * Initializes functionality to read mouse events and fires atom selection
     * when applicable. Fired on root mousedown.
     * 
     * handleTouch() and handleMouseDown() could possibly be consolidated into 
     * a pointer based event function since they are very similar.
     * 
     * @param event event object generated by mousedown event.
     */
    let handleMouseDown = function(event) {

        // handleMouseDown helper function to that is fired on mouseup. Fires atom selection on 
        // valid press and performs mouse functionality clean up since mouse event is ending. 
        let handleMouseup = function() {
            if(validPress) {
                // Use canvas generated by pv.Viewer() to calculate position of mouse event. However, it 
                // might be unnecessary. Refer to initialization of pvCanvas variable for possible alternatives.
                let pos = { x: event.clientX - pvCanvas.getBoundingClientRect().x, y: event.clientY - pvCanvas.getBoundingClientRect().y };
                
                handleInput(pos);
            }

            // Remove mousemove listener as mouse events are over.
            root.removeEventListener("mousemove", handleMousemove);
        }

        // handleMouseDown helper function to flag presses as invalid for atom selection if the user drags
        // viewer (most likely panning/rotating structure).
        let handleMousemove = function() {
            validPress = false;
        }

        let validPress = true;
        root.addEventListener("mouseup", handleMouseup, { once: true });
        root.addEventListener("mousemove", handleMousemove, { once: true });
    };

    /**
     * Selects atom for highlighting and label display based on given position.
     * Based on https://pv.readthedocs.io/en/latest/sample-hover.html.
     * 
     * @param pos cartesian coordinate object of where input is registered on viewer.
     */
    let handleInput = function(pos) {
        // Use built in viewer functionality to request object based on given position.
        let picked = viewerObj.pick(pos);

        // Do nothing if there is no previously picked atom and there is no atom return from viewerObj.pick(), or
        // if there is a previously picked atom but that same atom is selected again. 
        if((!prevPicked && !picked) || prevPicked && picked && picked.target() == prevPicked.atom) return;
        
        // Deselect any previously picked atoms. 
        if(prevPicked) {
            unHighlightAtom(prevPicked.node);
            prevPicked = null;
        }

        // If there is an atom returned from viewer.pick(), highlight and display label.
        if(picked) {
            let atom = picked.target();
            let atomNameComponents = atom.qualifiedName().split(".");
            let residueNum = atomNameComponents[1].substring(3);
            let proteinName = proteinDict[atomNameComponents[1].substring(0, 3)];

            // Used returned atom and atom node from viewer.pick to highlight selection. 
            highlightAtom(picked.node(), atom);

            // Construct text for atom label and show it.
            if(!proteinName) {
                atomLabel.innerHTML = "non-protein";
            } else if(proteinName == "water") {
                atomLabel.innerHTML = `${proteinName}`;
            } else {
                atomLabel.innerHTML = `Residue #${residueNum} | ${proteinName}`;
            }
            atomLabel.classList.remove("protein-viewer__atom-label--hidden");

            // Set atom as previously picked so we can deselect it in the future.
            prevPicked = { node: picked.node() }
        } else {
            // If no atom returned from viewer.pick(), empty space was clicked. So remove label (removing highlight 
            // was done earlier).
            atomLabel.classList.add("protein-viewer__atom-label--hidden");
        }

        // Use built in viewer.requestRedraw() to refresh and display all the changes to the viewer we made.
        viewerObj.requestRedraw();
    };

    /**
     * Highlights atom by using built in selection methods from pv. Selection
     * color is set with selectionColor when initializing viewerObj. Based on 
     * setColorForAtom() function in https://pv.readthedocs.io/en/latest/sample-hover.html.
     * 
     * @param geomObj node object returned from pv viewer.pick().node().
     * @param atom atom object returned from pv viewer.pick().target().
     */
    let highlightAtom = function(geomObj, atom) {
        // I am not sure about the details of this code. It is pretty much taken from the example linked
        // in this function documentation.
        let view = geomObj.structure().createEmptyView();
        view.addAtom(atom);
        geomObj.setSelection(view);
    };

    /**
     * Unhighlights atom by using built in selection methods from pv. Based on 
     * setColorForAtom() function in https://pv.readthedocs.io/en/latest/sample-hover.html.
     * 
     * @param geomObj node object returned from pv viewer.pick().node().
     */
    let unHighlightAtom = function(geomObj) {
        // Similar to highlight ataom, but select an empty view with no atoms added.
        let view = geomObj.structure().createEmptyView();
        geomObj.setSelection(view);
    };

    /**
     * Change the model type of the pdb based on the selection in model select 
     * elem. Fired on modelSelect change event.
     */
    let changeModel = function() {
        let modelType = modelSelect.value;
        let color = colorSelect.value;
        let options = {};

        // Set correct color value based on current current value of color select elem.
        if(color == "chain") {
            options.color = pv.color.byChain(chainGradient);
        } else if(color == "ss") {
            options.color = pv.color.bySS(ssGradient);
        }

        // Hide atom label and clear viewer object.
        atomLabel.classList.add("protein-viewer__atom-label--hidden");
        viewerObj.clear();

        // Render all models in structure with given model type.
        viewerStructs.forEach(function(viewerStruct, index) {
            viewerObj.renderAs(`structure_${index}`, viewerStruct, modelType, options);
        });

        // Unhighlight any previously picked atoms. Might not be necessary to unhighlight because of viewer.clear().
        // But still might be necessary to set prevPicked to null based on implementation of handleInut().
        if(prevPicked) {
            unHighlightAtom(prevPicked.node);
            prevPicked = null;
        }
    };

    /**
     * Change the color of the pdb based on the selection in color select 
     * elem. Fired on colorSelect change event.
     */
    let changeColor = function() {
        let color = colorSelect.value;

        // Rerender all models with selected color.
        viewerObj.forEach(function(geomObj) {
            if(color == "chain") {
                geomObj.colorBy(pv.color.byChain(chainGradient));
            } else if(color == "ss") {
                geomObj.colorBy(pv.color.bySS(ssGradient));
            }
        });

        // Use built in viewer.requestRedraw() to refresh and display all the changes to the viewer we made.
        viewerObj.requestRedraw();
    };

    // Add neccessary event listeners to dom elements.
    window.addEventListener("resize", resizeViewer);
    root.addEventListener("touchstart", handleTouch);
    root.addEventListener("mousedown", handleMouseDown);
    modelSelect.addEventListener("change", changeModel);
    colorSelect.addEventListener("change", changeColor);

    // Return public properties/methods.
    return {
        initialized,
        init,
        resizeViewer
    }
};